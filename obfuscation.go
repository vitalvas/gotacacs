package gotacacs

import (
	"crypto/md5"
	"encoding/binary"
)

// Obfuscate obfuscates or deobfuscates the body using the TACACS+ pseudo-pad algorithm.
// The operation is symmetric (XOR), so the same function is used for both operations.
// As defined in RFC8907 Section 4.5, the pseudo-pad is computed as:
//
//	pseudo_pad = {MD5(session_id + secret + version + seq_no) +
//	              MD5(session_id + secret + version + seq_no + pseudo_pad[0..15]) +
//	              MD5(session_id + secret + version + seq_no + pseudo_pad[0..31]) + ...}
//
// The body is XORed with the pseudo-pad to produce the obfuscated/deobfuscated result.
//
// If secret is empty or the header has FlagUnencrypted set, the body is returned unchanged.
func Obfuscate(header *Header, secret, body []byte) []byte {
	if len(secret) == 0 || header.IsUnencrypted() || len(body) == 0 {
		return body
	}

	pad := generatePseudoPad(header, secret, len(body))
	result := make([]byte, len(body))
	for i := range body {
		result[i] = body[i] ^ pad[i]
	}

	return result
}

// Deobfuscate is an alias for Obfuscate since XOR is symmetric.
func Deobfuscate(header *Header, secret, body []byte) []byte {
	return Obfuscate(header, secret, body)
}

// generatePseudoPad generates the pseudo-pad for obfuscation/deobfuscation.
// The pseudo-pad is generated by iteratively hashing:
//
//	MD5(session_id || secret || version || seq_no || previous_hash_if_any)
//
// This continues until the pad is at least as long as the body.
func generatePseudoPad(header *Header, secret []byte, length int) []byte {
	if length == 0 {
		return nil
	}

	// Prepare the base data: session_id (4 bytes) + secret + version (1 byte) + seq_no (1 byte)
	sessionIDBytes := make([]byte, 4)
	binary.BigEndian.PutUint32(sessionIDBytes, header.SessionID)

	baseData := make([]byte, 0, 4+len(secret)+2)
	baseData = append(baseData, sessionIDBytes...)
	baseData = append(baseData, secret...)
	baseData = append(baseData, header.Version)
	baseData = append(baseData, header.SeqNo)

	// Generate enough pseudo-pad bytes
	pad := make([]byte, 0, ((length/md5.Size)+1)*md5.Size)
	var prevHash []byte

	for len(pad) < length {
		h := md5.New()
		h.Write(baseData)
		if prevHash != nil {
			h.Write(prevHash)
		}
		prevHash = h.Sum(nil)
		pad = append(pad, prevHash...)
	}

	return pad[:length]
}
