package gotacacs

import (
	"crypto/md5"
	"encoding/binary"
)

// Obfuscate obfuscates or deobfuscates the body using the TACACS+ pseudo-pad algorithm.
// The operation is symmetric (XOR), so the same function is used for both operations.
// As defined in RFC8907 Section 4.5, the pseudo-pad is computed as:
//
//	pseudo_pad = {MD5(session_id + secret + version + seq_no) +
//	              MD5(session_id + secret + version + seq_no + pseudo_pad[0..15]) +
//	              MD5(session_id + secret + version + seq_no + pseudo_pad[0..31]) + ...}
//
// The body is XORed with the pseudo-pad to produce the obfuscated/deobfuscated result.
//
// If secret is empty or the header has FlagUnencrypted set, the body is returned unchanged.
func Obfuscate(header *Header, secret, body []byte) []byte {
	if len(secret) == 0 || header.IsUnencrypted() || len(body) == 0 {
		return body
	}

	pad := generatePseudoPad(header, secret, len(body))
	result := make([]byte, len(body))
	for i := range body {
		result[i] = body[i] ^ pad[i]
	}

	return result
}

// generatePseudoPad generates the pseudo-pad for obfuscation/deobfuscation.
// The pseudo-pad is generated by iteratively hashing:
//
//	MD5(session_id || secret || version || seq_no || previous_hash_if_any)
//
// This continues until the pad is at least as long as the body.
func generatePseudoPad(header *Header, secret []byte, length int) []byte {
	if length == 0 {
		return nil
	}

	// Calculate number of MD5 blocks needed
	numBlocks := (length + md5.Size - 1) / md5.Size
	pad := make([]byte, numBlocks*md5.Size)

	// Prepare input buffer: session_id (4) + secret + version (1) + seq_no (1) + prevHash (16)
	baseLen := 4 + len(secret) + 2
	input := make([]byte, baseLen+md5.Size)
	binary.BigEndian.PutUint32(input[0:4], header.SessionID)
	copy(input[4:], secret)
	input[4+len(secret)] = header.Version
	input[4+len(secret)+1] = header.SeqNo

	// Generate pseudo-pad blocks using md5.Sum (returns [16]byte, no allocation)
	for i := 0; i < numBlocks; i++ {
		var hash [md5.Size]byte
		if i == 0 {
			hash = md5.Sum(input[:baseLen])
		} else {
			hash = md5.Sum(input[:baseLen+md5.Size])
		}
		copy(pad[i*md5.Size:], hash[:])
		copy(input[baseLen:], hash[:])
	}

	return pad[:length]
}
